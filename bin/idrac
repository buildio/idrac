#!/usr/bin/env ruby

# Attempt to load bundler/setup, but don't fail if it's not available
begin
  require "bundler/setup"
rescue LoadError
  # Continue without bundler
end

# Load required gems directly
require "thor"
require "idrac"
require "colorize"
require "json"

module IDRAC
  class CLI < Thor
    # Make host not required for all commands
    class_option :host, type: :string, required: false, desc: "iDRAC host address"
    class_option :username, type: :string, required: false, default: "root", desc: "iDRAC username"
    class_option :password, type: :string, required: false, default: "calvin", desc: "iDRAC password"
    class_option :port, type: :numeric, default: 443, desc: "iDRAC port"
    class_option :no_ssl, type: :boolean, default: false, desc: "Disable SSL"
    class_option :verify_ssl, type: :boolean, default: false, desc: "Enable SSL verification (not recommended for iDRAC's self-signed certificates)"
    class_option :auto_delete_sessions, type: :boolean, default: true, desc: "Automatically delete sessions when maximum sessions are reached"
    class_option :retries, type: :numeric, default: 3, desc: "Number of retries for API calls"
    class_option :retry_delay, type: :numeric, default: 1, desc: "Initial delay in seconds between retries (increases exponentially)"
    class_option :verbose, type: :boolean, default: false, aliases: '-v', desc: "Enable verbose output"
    class_option :very_verbose, type: :boolean, default: false, aliases: '-vv', desc: "Enable very verbose output with detailed headers and requests"
    class_option :debug, type: :boolean, default: false, aliases: '-vvv', desc: "Enable debug output with detailed stack traces and SSL info"

    def self.exit_on_failure?
      true
    end
    
    # Helper methods that shouldn't be exposed as commands
    no_commands do
      # Override the built-in help command to modify displayed command names
      def help(command = nil)
        if command
          super
        else
          # Get the formatted help output
          output = capture_stdout { super }
          
          # First handle methods with multiple underscores (like jobs_force_clear)
          modified_output = output.gsub(/idrac (\w+)_(\w+)_(\w+)/) do |match|
            "idrac #{$1}:#{$2}:#{$3}"
          end
          
          # Then handle methods with a single underscore (like lifecycle_status)
          modified_output = modified_output.gsub(/idrac (\w+)_(\w+)/) do |match|
            "idrac #{$1}:#{$2}"
          end
          
          puts modified_output
        end
      end
      
      # Utility method to capture stdout
      def capture_stdout
        original_stdout = $stdout
        $stdout = StringIO.new
        yield
        $stdout.string
      ensure
        $stdout = original_stdout
      end
    end
    
    desc "jobs_list", "List all iDRAC jobs"
    map "jobs:list" => :jobs_list
    def jobs_list
      with_idrac_client do |client|
        client.jobs
      end
    end
    
    desc "jobs_detail", "List detailed job information"
    map "jobs:detail" => :jobs_detail
    def jobs_detail
      with_idrac_client do |client|
        client.jobs_detail
      end
    end
    
    desc "jobs_clear", "Clear all jobs from the job queue"
    map "jobs:clear" => :jobs_clear
    def jobs_clear
      with_idrac_client do |client|
        client.clear_jobs!
      end
    end
    
    desc "jobs_force_clear", "Force clear the job queue"
    map "jobs:force_clear" => :jobs_force_clear
    map "jobs:force:clear" => :jobs_force_clear
    def jobs_force_clear
      with_idrac_client do |client|
        client.force_clear_jobs!
      end
    end
    
    desc "jobs_wait JOB_ID", "Wait for a specific job to complete"
    map "jobs:wait" => :jobs_wait
    def jobs_wait(job_id)
      with_idrac_client do |client|
        job_data = client.wait_for_job(job_id)
        puts "Job completed: #{job_data['Id']} - #{job_data['JobState']} - #{job_data['Message']}".green
      end
    end
    
    desc "tasks", "List iDRAC tasks"
    def tasks
      with_idrac_client do |client|
        client.tasks
      end
    end
    
    desc "lifecycle_status", "Check if Lifecycle Controller is enabled"
    map "lifecycle:status" => :lifecycle_status
    def lifecycle_status
      with_idrac_client do |client|
        client.get_lifecycle_status
      end
    end
    
    desc "lifecycle_enable", "Enable Lifecycle Controller"
    map "lifecycle:enable" => :lifecycle_enable
    def lifecycle_enable
      with_idrac_client do |client|
        client.set_lifecycle_status(true)
      end
    end
    
    desc "lifecycle_disable", "Disable Lifecycle Controller"
    map "lifecycle:disable" => :lifecycle_disable
    def lifecycle_disable
      with_idrac_client do |client|
        client.set_lifecycle_status(false)
      end
    end
    
    desc "lifecycle_ensure", "Ensure Lifecycle Controller is enabled"
    map "lifecycle:ensure" => :lifecycle_ensure
    def lifecycle_ensure
      with_idrac_client do |client|
        client.ensure_lifecycle_controller!
      end
    end
    
    desc "lifecycle_clear", "Clear Lifecycle log"
    map "lifecycle:clear" => :lifecycle_clear
    def lifecycle_clear
      with_idrac_client do |client|
        client.clear_lifecycle!
      end
    end
    
    desc "sel_clear", "Clear System Event Logs (SEL)"
    map "sel:clear" => :sel_clear
    def sel_clear
      with_idrac_client do |client|
        client.clear_system_event_logs!
      end
    end

    desc "firmware_update PATH", "Update firmware using the specified file"
    map "firmware:update" => :firmware_update
    method_option :wait, type: :boolean, default: true, desc: "Wait for the update to complete"
    method_option :timeout, type: :numeric, default: 3600, desc: "Timeout in seconds when waiting"
    def firmware_update(path)
      with_idrac_client do |client|
        firmware = IDRAC::Firmware.new(client)
        job_id = firmware.update(path, wait: options[:wait], timeout: options[:timeout])
        puts "Firmware update initiated with job ID: #{job_id}"
      end
    end
    
    desc "firmware_catalog [DIRECTORY]", "Download Dell firmware catalog"
    map "firmware:catalog" => :firmware_catalog
    def firmware_catalog(directory = nil)
      # This command doesn't require a host
      catalog = IDRAC::FirmwareCatalog.new
      
      begin
        puts "Downloading Dell catalog...".light_cyan
        catalog_path = catalog.download(directory)
        puts "Catalog downloaded to: #{catalog_path}".green
      rescue IDRAC::Error => e
        puts "Error: #{e.message}".red.bold
        exit 1
      end
    end
    
    desc "firmware_status", "Show current firmware status and available updates"
    map "firmware:status" => :firmware_status
    method_option :catalog, type: :string, desc: "Path to existing catalog file"
    def firmware_status
      with_idrac_client do |client|
        firmware = IDRAC::Firmware.new(client)
        
        # Get system inventory - the Firmware class will print its own message
        inventory = firmware.get_system_inventory
        
        puts "System Information:".green.bold
        puts "  Model: #{inventory[:system][:model]}".light_cyan
        puts "  Manufacturer: #{inventory[:system][:manufacturer]}".light_cyan
        puts "  Service Tag: #{inventory[:system][:service_tag]}".light_cyan
        puts "  BIOS Version: #{inventory[:system][:bios_version]}".light_cyan
        
        puts "\nInstalled Firmware:".green.bold
        inventory[:firmware].each do |fw|
          puts "  #{fw[:name]}: #{fw[:version]} (#{fw[:updateable] ? 'Updateable'.light_green : 'Not Updateable'.light_red})".light_cyan
        end
        
        # Default catalog location is now ~/.idrac/Catalog.xml
        default_catalog = File.expand_path("~/.idrac/Catalog.xml")
        
        # Check for updates if catalog is available
        if options[:catalog] || File.exist?(default_catalog)
          catalog_path = options[:catalog] || default_catalog
          
          # Check for updates using the firmware class
          updates = firmware.check_updates(catalog_path)
          
          if updates.empty?
            puts "\nNo updates available.".yellow
          end
        else
          puts "\nTo check for updates, download the catalog first with 'idrac firmware:catalog'".yellow
        end
      end
    end
    
    desc "firmware_interactive", "Interactive firmware update"
    map "firmware:interactive" => :firmware_interactive
    method_option :catalog, type: :string, desc: "Path to existing catalog file"
    def firmware_interactive
      with_idrac_client do |client|
        firmware = IDRAC::Firmware.new(client)
        
        catalog_path = options[:catalog]
        
        # Default catalog location is now ~/.idrac/Catalog.xml
        default_catalog = File.expand_path("~/.idrac/Catalog.xml")
        
        # If no catalog specified, check if one exists in the default location
        if catalog_path.nil? && File.exist?(default_catalog)
          catalog_path = default_catalog
        end
        
        # If still no catalog, download it
        if catalog_path.nil?
          puts "No catalog found. Downloading...".yellow
          catalog = IDRAC::FirmwareCatalog.new
          catalog_path = catalog.download
        end
        
        puts "Starting interactive firmware update. Please note:".green.bold
        puts "- The iDRAC can only process one firmware update at a time".light_cyan
        puts "- Updates may take several minutes to complete".light_cyan
        puts "- For BIOS updates, a server reboot will be required to apply the update".light_cyan
        puts "- If you encounter errors, check the iDRAC web interface for active jobs".light_cyan
        puts ""
        
        begin
          firmware.interactive_update(catalog_path)
        rescue ArgumentError => e
          puts "Error: #{e.message}".red.bold
          puts "This could be due to an issue with the interactive update process.".yellow
          puts "If you're seeing a 'job ID not found' error, it might be because:".yellow
          puts "1. The firmware update job wasn't created properly".light_yellow
          puts "2. There's already an update in progress".light_yellow
          puts "3. The iDRAC needs time to process the previous request".light_yellow
          puts "\nTry again in a few minutes or check the iDRAC web interface for active jobs.".light_cyan
        rescue IDRAC::Error => e
          if e.message.include?("already in progress")
            puts "Error: #{e.message}".red.bold
            puts "\nTroubleshooting steps:".yellow.bold
            puts "1. Check the iDRAC web interface under Maintenance > System Update for active jobs".light_yellow
            puts "2. Wait for any existing updates to complete (can take 15-30 minutes)".light_yellow
            puts "3. If no updates appear to be in progress, you may need to restart the iDRAC".light_yellow
            puts "   (iDRAC web interface > Settings > iDRAC Settings > Reset iDRAC)".light_yellow
          else
            raise # re-raise for the wrapper to handle
          end
        end
      end
    end
    
    desc "screenshot", "Take a screenshot of the current iDRAC console"
    method_option :output, type: :string, desc: "Output filename (default: idrac_screenshot_timestamp.png)"
    def screenshot
      with_idrac_client do |client|
        # Capture a screenshot using the client
        filename = client.screenshot
        
        # Rename the file if output option is provided
        if options[:output]
          new_filename = options[:output]
          File.rename(filename, new_filename)
          filename = new_filename
        end
        
        puts "Screenshot saved to: #{filename}"
      end
    end
    
    desc "summary", "Display a summary of system information"
    def summary
      with_idrac_client do |client|
        verbose = options[:verbose] || options[:very_verbose] || options[:debug]
        
        # Get system information using authenticated_request
        puts "Retrieving system information...".light_yellow if verbose
        system_response = client.authenticated_request(:get, "/redfish/v1/Systems/System.Embedded.1")
        system_info = JSON.parse(system_response.body)
        puts JSON.pretty_generate(system_info).light_yellow if verbose
        
        # Get iDRAC information using authenticated_request
        puts "Retrieving iDRAC information...".light_yellow if verbose
        idrac_response = client.authenticated_request(:get, "/redfish/v1/Managers/iDRAC.Embedded.1")
        idrac_info = JSON.parse(idrac_response.body)
        puts JSON.pretty_generate(idrac_info).light_yellow if verbose
        
        # Get network information using authenticated_request
        puts "Retrieving network information...".light_yellow if verbose
        network_response = client.authenticated_request(:get, "/redfish/v1/Managers/iDRAC.Embedded.1/EthernetInterfaces/NIC.1")
        network_info = JSON.parse(network_response.body)
        puts JSON.pretty_generate(network_info).light_yellow if verbose
        
        # Initialize license_type to Unknown
        license_type = "Unknown"
        license_description = nil
        
        # Try to get license information using DMTF standard method
        begin
          puts "Retrieving license information (DMTF method)...".light_yellow if verbose
          license_response = client.authenticated_request(:get, "/redfish/v1/LicenseService/Licenses")
          license_info = JSON.parse(license_response.body)
          puts JSON.pretty_generate(license_info).light_yellow if verbose
          
          # Extract license type if licenses are found
          if license_info["Members"] && !license_info["Members"].empty?
            license_entry_response = client.authenticated_request(:get, license_info["Members"][0]["@odata.id"])
            license_entry = JSON.parse(license_entry_response.body)
            puts JSON.pretty_generate(license_entry).light_yellow if verbose
            
            # Get license type from EntitlementId or LicenseType
            if license_entry["EntitlementId"] && license_entry["EntitlementId"].include?("Enterprise")
              license_type = "Enterprise"
            elsif license_entry["LicenseType"]
              license_type = license_entry["LicenseType"]
            end
            
            # Get license description if available
            license_description = license_entry["Description"] if license_entry["Description"]
          end
        rescue => e
          puts "Error retrieving license information using DMTF method: #{e.message}".light_red if verbose
          
          # If DMTF method fails, try Dell OEM method
          begin
            puts "Retrieving license information (Dell OEM method)...".light_yellow if verbose
            dell_license_response = client.authenticated_request(:get, "/redfish/v1/Managers/iDRAC.Embedded.1/Oem/Dell/DellLicenses")
            dell_license_info = JSON.parse(dell_license_response.body)
            puts JSON.pretty_generate(dell_license_info).light_yellow if verbose
            
            # Extract license type if licenses are found
            if dell_license_info["Members"] && !dell_license_info["Members"].empty?
              dell_license_entry_response = client.authenticated_request(:get, dell_license_info["Members"][0]["@odata.id"])
              dell_license_entry = JSON.parse(dell_license_entry_response.body)
              puts JSON.pretty_generate(dell_license_entry).light_yellow if verbose
              
              # Get license type from LicenseType or Description
              if dell_license_entry["LicenseType"]
                license_type = dell_license_entry["LicenseType"]
              elsif dell_license_entry["Description"] && dell_license_entry["Description"].include?("Enterprise")
                license_type = "Enterprise"
              end
              
              # Get license description if available
              license_description = dell_license_entry["Description"] if dell_license_entry["Description"]
            end
          rescue => e2
            puts "Error retrieving Dell license information: #{e2.message}".light_red if verbose
          end
        end
        
        # Format the license display string
        license_display = license_type
        if license_description
          license_display = "#{license_type} (#{license_description})"
        end
        
        # Format and display the information
        puts "System Summary:".green.bold
        puts "=" * 50
        
        puts "Power State:".ljust(25) + (system_info["PowerState"] || "Unknown").light_cyan
        puts "Model:".ljust(25) + (system_info["Model"] || "Unknown").light_cyan
        puts "Host Name:".ljust(25) + (system_info["HostName"] || "Unknown").light_cyan
        puts "Operating System:".ljust(25) + (system_info.dig("Oem", "Dell", "OperatingSystem") || "Unknown").light_cyan
        puts "Operating System Version:".ljust(25) + (system_info.dig("Oem", "Dell", "OperatingSystemVersion") || "Unknown").light_cyan
        puts "Service Tag:".ljust(25) + (system_info["SKU"] || "Unknown").light_cyan
        puts "BIOS Version:".ljust(25) + (system_info.dig("BiosVersion") || "Unknown").light_cyan
        puts "iDRAC Firmware Version:".ljust(25) + (idrac_info.dig("FirmwareVersion") || "Unknown").light_cyan
        puts "IP Address:".ljust(25) + (network_info.dig("IPv4Addresses", 0, "Address") || "Unknown").light_cyan
        puts "iDRAC MAC Address:".ljust(25) + (network_info.dig("MACAddress") || "Unknown").light_cyan
        puts "License:".ljust(25) + license_display.light_cyan
        
        puts "=" * 50
      end
    end
    
    desc "power_state", "Get current server power state"
    map "power:state" => :power_state
    def power_state
      with_idrac_client do |client|
        state = client.get_power_state
        puts "Current power state: #{state}".light_cyan
      end
    end
    
    desc "power_on", "Power on the server"
    map "power:on" => :power_on
    def power_on
      with_idrac_client do |client|
        client.power_on
      end
    end
    
    desc "power_off", "Power off the server"
    map "power:off" => :power_off
    def power_off
      with_idrac_client do |client|
        client.power_off
      end
    end
    
    desc "power_reboot", "Reboot the server"
    map "power:reboot" => :power_reboot
    def power_reboot
      with_idrac_client do |client|
        client.reboot
      end
    end
    
    desc "redfish_version", "Display the Redfish API version"
    map "redfish:version" => :redfish_version
    def redfish_version
      with_idrac_client do |client|
        version = client.redfish_version
        puts version
      end
    end

    # Storage commands
    desc "storage_controller", "Get storage controller information"
    map "storage:controller" => :storage_controller
    def storage_controller
      with_idrac_client do |client|
        controller = client.controller
        puts "\nStorage Controller Summary:".green.bold
        puts "Name: #{controller['Name']}".cyan
        puts "Model: #{controller['Model']}".cyan
        puts "Health: #{controller['Status']['Health']}".cyan
        puts "Manufacturer: #{controller['Manufacturer']}".cyan
        
        if client.controller_encryption_capable?(controller)
          puts "Encryption Capable: Yes".green
          puts "Encryption Enabled: #{client.controller_encryption_enabled?(controller) ? 'Yes'.green : 'No'.yellow}"
        else
          puts "Encryption Capable: No".yellow
        end
      end
    end

    desc "storage_drives", "Get physical drive information"
    map "storage:drives" => :storage_drives
    def storage_drives
      with_idrac_client do |client|
        controller = client.controller
        drives = client.drives(controller)
        
        puts "\nPhysical Drives (#{drives.size}):".green.bold
        drives.each do |drive|
          capacity_gb = drive[:capacity_bytes].to_f / (1024**3)
          health_color = drive[:health] == "OK" ? :green : :red
          
          puts "#{drive[:name]}:".bold
          puts "  Model: #{drive[:model]}".cyan
          puts "  Health: #{drive[:health].send(health_color)}"
          puts "  Capacity: #{capacity_gb.round(2)} GB".cyan
          puts "  Media Type: #{drive[:media_type]}".cyan
          puts "  Serial: #{drive[:serial]}".cyan
          if drive[:encryption_ability]
            puts "  Encryption: #{drive[:encryption_ability]}".cyan
          end
          puts ""
        end
      end
    end

    desc "storage_volumes", "Get virtual disk information"
    map "storage:volumes" => :storage_volumes
    def storage_volumes
      with_idrac_client do |client|
        controller = client.controller
        volumes = client.volumes(controller)
        
        puts "\nVirtual Disks (#{volumes.size}):".green.bold
        volumes.each do |volume|
          capacity_gb = volume[:capacity_bytes].to_f / (1024**3)
          health_color = volume[:health] == "OK" ? :green : :yellow
          
          puts "#{volume[:name]}:".bold
          puts "  RAID Type: #{volume[:raid_level] || volume[:volume_type]}".cyan
          puts "  Health: #{volume[:health].send(health_color)}"
          puts "  Capacity: #{capacity_gb.round(2)} GB".cyan
          puts "  Stripe Size: #{volume[:stripe_size]}".cyan
          puts "  Read Cache: #{volume[:read_cache_policy]}".cyan
          puts "  Write Cache: #{volume[:write_cache_policy]}".cyan
          puts "  FastPath: #{volume[:fastpath] == 'enabled' ? 'Enabled'.green : 'Disabled'.yellow}"
          puts "  Encrypted: #{volume[:encrypted] ? 'Yes'.green : 'No'.yellow}" if volume[:encrypted] != nil
          
          if volume[:progress]
            puts "  Progress: #{volume[:progress]}%".cyan
            puts "  Operation: #{volume[:message]}".cyan
          end
          puts ""
        end
      end
    end

    desc "storage_create_volume", "Create a new virtual disk"
    map "storage:create_volume" => :storage_create_volume
    method_option :name, type: :string, default: "vssd0", desc: "Volume name"
    method_option :raid, type: :string, default: "RAID5", desc: "RAID type (RAID0, RAID1, RAID5, RAID6, RAID10)"
    def storage_create_volume
      with_idrac_client do |client|
        controller = client.controller
        drives = client.drives(controller)
        
        # Confirm with the user before proceeding
        puts "This will create a new #{options[:raid]} volume named '#{options[:name]}' using #{drives.size} drives.".yellow
        puts "All data on these drives will be lost!".red.bold
        
        print "Do you want to continue? (y/n): "
        confirmation = $stdin.gets.chomp.downcase
        
        if confirmation == 'y'
          client.create_virtual_disk(controller['Id'], drives, name: options[:name], raid_type: options[:raid])
          puts "Volume created successfully".green
        else
          puts "Operation cancelled".yellow
        end
      end
    end

    desc "storage_delete_volume", "Delete a virtual disk"
    map "storage:delete_volume" => :storage_delete_volume
    def storage_delete_volume
      with_idrac_client do |client|
        controller = client.controller
        volumes = client.volumes(controller)
        
        if volumes.empty?
          puts "No volumes found to delete".yellow
          return
        end
        
        puts "Available volumes:".green
        volumes.each_with_index do |vol, idx|
          puts "#{idx+1}. #{vol[:name]} (#{vol[:raid_level] || vol[:volume_type]}, #{(vol[:capacity_bytes].to_f / (1024**3)).round(2)} GB)"
        end
        
        print "Enter the number of the volume to delete (or 'q' to quit): "
        input = $stdin.gets.chomp
        
        if input.downcase == 'q'
          puts "Operation cancelled".yellow
          return
        end
        
        index = input.to_i - 1
        if index >= 0 && index < volumes.size
          volume = volumes[index]
          
          puts "You are about to delete '#{volume[:name]}'. All data will be lost!".red.bold
          print "Type the volume name to confirm deletion: "
          confirm = $stdin.gets.chomp
          
          if confirm == volume[:name]
            client.delete_volume(volume[:"@odata.id"])
            puts "Volume deleted successfully".green
          else
            puts "Volume name did not match. Operation cancelled".yellow
          end
        else
          puts "Invalid selection".red
        end
      end
    end

    desc "storage_encryption_enable", "Enable Self-Encrypting Drive (SED) support"
    map "storage:encryption_enable" => :storage_encryption_enable
    method_option :passphrase, type: :string, desc: "Encryption passphrase"
    method_option :keyid, type: :string, desc: "Key identifier"
    def storage_encryption_enable
      with_idrac_client do |client|
        controller = client.controller
        drives = client.drives(controller)
        
        if !client.controller_encryption_capable?(controller)
          puts "This controller does not support encryption".red
          return
        end
        
        if client.controller_encryption_enabled?(controller)
          puts "Encryption is already enabled on this controller".yellow
          return
        end
        
        if !client.all_seds?(drives)
          puts "Not all drives are Self-Encrypting Drives (SEDs)".red
          return
        end
        
        # Get passphrase if not provided
        passphrase = options[:passphrase]
        if passphrase.nil?
          print "Enter encryption passphrase (min 8 characters): "
          passphrase = $stdin.noecho(&:gets).chomp
          puts
        end
        
        # Get keyid if not provided
        keyid = options[:keyid] || "RAID-Key-#{Time.now.strftime('%Y%m%d')}"
        
        client.enable_local_key_management(controller['Id'], passphrase: passphrase, keyid: keyid)
        puts "Encryption enabled successfully".green
      end
    end

    desc "storage_encryption_disable", "Disable Self-Encrypting Drive (SED) support"
    map "storage:encryption_disable" => :storage_encryption_disable
    def storage_encryption_disable
      with_idrac_client do |client|
        controller = client.controller
        
        if !client.controller_encryption_enabled?(controller)
          puts "Encryption is not enabled on this controller".yellow
          return
        end
        
        puts "WARNING: Disabling encryption may prevent access to encrypted data!".red.bold
        print "Type 'DISABLE' to confirm: "
        confirmation = $stdin.gets.chomp
        
        if confirmation == 'DISABLE'
          client.disable_local_key_management(controller['Id'])
          puts "Encryption disabled successfully".green
        else
          puts "Operation cancelled".yellow
        end
      end
    end
    
    # System component commands
    desc "system_memory", "Get memory/DIMM information"
    map "system:memory" => :system_memory
    def system_memory
      with_idrac_client do |client|
        memory = client.memory
        
        puts "\nMemory Modules (#{memory.size}):".green.bold
        memory.each do |dimm|
          capacity_gb = dimm["capacity_bytes"].to_f / (1024**3)
          health_color = dimm["health"] == "OK" ? :green : :red
          
          puts "#{dimm['name']}:".bold
          puts "  Model: #{dimm['model']}".cyan
          puts "  Health: #{dimm['health'].send(health_color)}"
          puts "  Capacity: #{capacity_gb.round(2)} GB".cyan
          puts "  Speed: #{dimm['speed_mhz']} MHz".cyan
          puts "  Serial: #{dimm['serial']}".cyan
          puts ""
        end
        
        # Show total memory
        puts "Total Memory: #{client.total_memory_human(memory)}".green.bold
      end
    end

    desc "system_psus", "Get power supply information"
    map "system:psus" => :system_psus
    def system_psus
      with_idrac_client do |client|
        psus = client.psus
        
        puts "\nPower Supplies (#{psus.size}):".green.bold
        psus.each do |psu|
          health_color = psu["status"] == "OK" ? :green : :red
          
          puts "#{psu['name']}:".bold
          puts "  Model: #{psu['model']}".cyan
          puts "  Health: #{psu['status'].send(health_color)}"
          puts "  Input: #{psu['voltage']} V (#{psu['voltage_human']})".cyan
          puts "  Output: #{psu['watts']} W".cyan
          puts "  Serial: #{psu['serial']}".cyan
          puts ""
        end
      end
    end

    desc "system_fans", "Get fan information"
    map "system:fans" => :system_fans
    def system_fans
      with_idrac_client do |client|
        fans = client.fans
        
        if fans.empty?
          puts "No fan information available (system might be powered off)".yellow
          return
        end
        
        puts "\nFans (#{fans.size}):".green.bold
        fans.each do |fan|
          health_color = fan["status"] == "OK" ? :green : :red
          
          puts "#{fan['name']}:".bold
          puts "  Health: #{fan['status'].send(health_color)}"
          puts "  Speed: #{fan['rpm']} RPM".cyan
          puts ""
        end
      end
    end

    desc "system_nics", "Get network adapter information"
    map "system:nics" => :system_nics
    def system_nics
      with_idrac_client do |client|
        nics = client.nics
        pci = client.pci_devices
        nics_with_pci = client.nics_to_pci(nics, pci)
        
        puts "\nNetwork Adapters (#{nics_with_pci.size}):".green.bold
        nics_with_pci.each do |nic|
          puts "#{nic['name']}:".bold
          puts "  Manufacturer: #{nic['manufacturer']}".cyan
          puts "  Model: #{nic['model']}".cyan
          
          if nic['ports'] && nic['ports'].any?
            puts "  Ports:".cyan
            nic['ports'].each do |port|
              status_color = port["status"] == "Up" ? :green : :yellow
              
              puts "    #{port['name']}:".bold
              puts "      Status: #{port['status'].send(status_color)}"
              puts "      MAC: #{port['mac']}".cyan
              puts "      Speed: #{port['speed_mbps']} Mbps".cyan
              if port['pci']
                puts "      PCI Bus: #{port['pci']}".cyan
                puts "      Linux Device: #{port['linux_device']}".cyan
              end
              puts ""
            end
          end
          puts ""
        end
      end
    end

    desc "system_idrac_network", "Get iDRAC network configuration"
    map "system:idrac_network" => :system_idrac_network
    def system_idrac_network
      with_idrac_client do |client|
        idrac = client.idrac_network
        
        puts "\niDRAC Network Configuration:".green.bold
        puts "Status: #{idrac['status']}".cyan
        puts "IPv4: #{idrac['ipv4']}".cyan
        puts "Subnet Mask: #{idrac['mask']}".cyan
        puts "MAC Address: #{idrac['mac']}".cyan
        puts "Origin: #{idrac['origin']}".cyan
        puts "Speed: #{idrac['speed_mbps']} Mbps".cyan
      end
    end

    desc "system_events", "Get system event logs"
    map "system:events" => :system_events
    def system_events
      with_idrac_client do |client|
        events = client.system_event_logs
        
        puts "\nSystem Events (#{events.size}):".green.bold
        events.each do |event|
          severity_color = case event[:severity]
                          when "Critical" then :red
                          when "Warning" then :yellow
                          else :cyan
                          end
          
          puts "#{event[:id]} - #{event[:created]} - #{event[:severity].send(severity_color)} - #{event[:message]}"
        end
      end
    end
    
    # Virtual media commands
    desc "vmedia_status", "Get virtual media status"
    map "vmedia:status" => :vmedia_status
    def vmedia_status
      with_idrac_client do |client|
        media = client.virtual_media
        
        puts "\nVirtual Media Status:".green.bold
        
        if media.empty?
          puts "No virtual media devices found".yellow
          return
        end
        
        media.each do |m|
          status = m[:inserted] ? "Inserted: #{m[:image]}".green : "Not Inserted".yellow
          puts "#{m[:device]}: #{status}"
        end
      end
    end

    desc "vmedia_insert URL", "Insert virtual media from URL"
    map "vmedia:insert" => :vmedia_insert
    method_option :device, type: :string, default: "CD", desc: "Device type (CD or RemovableDisk)"
    def vmedia_insert(url)
      with_idrac_client do |client|
        puts "Inserting media from #{url} into #{options[:device]}..."
        client.insert_virtual_media(url, device: options[:device])
      end
    end

    desc "vmedia_eject", "Eject virtual media"
    map "vmedia:eject" => :vmedia_eject
    method_option :device, type: :string, default: "CD", desc: "Device to eject (CD or RemovableDisk)"
    def vmedia_eject
      with_idrac_client do |client|
        client.eject_virtual_media(device: options[:device])
      end
    end

    desc "vmedia_boot_once", "Set system to boot from virtual media once"
    map "vmedia:boot_once" => :vmedia_boot_once
    def vmedia_boot_once
      with_idrac_client do |client|
        client.set_one_time_virtual_media_boot
        puts "System configured to boot from virtual media on next restart"
      end
    end
    
    # Boot management commands
    desc "boot_options", "Get current boot options"
    map "boot:options" => :boot_options
    def boot_options
      with_idrac_client do |client|
        options = client.get_bios_boot_options
        
        if options == false
          puts "Failed to get boot options. System may not be in UEFI mode.".red
          return
        end
        
        puts "\nBoot Options:".green.bold
        
        # Display enabled boot options (current boot order)
        puts "Current Boot Order:".cyan
        options[:boot_order].each_with_index do |opt, idx|
          puts "  #{idx+1}. #{opt}"
        end
        
        # Display all available boot options
        puts "\nAvailable Boot Options:".cyan
        options[:boot_options].each do |opt|
          enabled = options[:boot_order].include?(opt)
          status = enabled ? "Enabled".green : "Disabled".yellow
          puts "  #{opt}: #{status}"
        end
      end
    end

    desc "boot_enable_uefi", "Enable UEFI boot mode"
    map "boot:enable_uefi" => :boot_enable_uefi
    def boot_enable_uefi
      with_idrac_client do |client|
        client.ensure_uefi_boot
      end
    end

    desc "boot_set_hd_first", "Set boot order with hard drive first"
    map "boot:set_hd_first" => :boot_set_hd_first
    def boot_set_hd_first
      with_idrac_client do |client|
        client.set_boot_order_hd_first
      end
    end

    desc "boot_ignore_errors", "Configure BIOS to ignore boot errors"
    map "boot:ignore_errors" => :boot_ignore_errors
    method_option :enable, type: :boolean, default: true, desc: "Enable or disable ignoring boot errors"
    def boot_ignore_errors
      with_idrac_client do |client|
        client.set_bios_ignore_errors(options[:enable])
        if options[:enable]
          puts "BIOS configured to ignore boot errors".green
        else
          puts "BIOS configured to halt on boot errors".green
        end
      end
    end

    desc "boot_power_optimization", "Configure BIOS for OS-controlled power management"
    map "boot:power_optimization" => :boot_power_optimization
    def boot_power_optimization
      with_idrac_client do |client|
        client.set_bios_os_power_control
        puts "BIOS configured for OS power management optimization".green
      end
    end

    desc "boot_source_override", "Get current boot source override settings"
    map "boot:source_override" => :boot_source_override
    def boot_source_override
      with_idrac_client do |client|
        client.get_boot_source_override
      end
    end

    # Test commands
    desc "test_live", "Test all major functionality of the gem on a real system"
    map "test:live" => :test_live
    method_option :timeout, type: :numeric, default: 10, desc: "Connection timeout in seconds"
    def test_live
      test_results = {}
      
      puts "Running comprehensive live test of idrac gem functionality...".green.bold
      puts "=" * 80
      puts "This will test all read-only operations of the gem. No changes will be made to your system.".yellow
      puts "Using connection timeout of #{options[:timeout]} seconds (use --timeout=X to change)".yellow
      puts "=" * 80
      
      with_idrac_client do |client|
        # Set higher verbosity temporarily for comprehensive logging
        original_verbosity = client.verbosity
        
        # Configure verbosity level based on user options
        if options[:very_verbose] || options[:debug]
          client.verbosity = options[:debug] ? 3 : 2
          puts "HTTP request/response details will be shown (verbosity level: #{client.verbosity})".cyan
        else
          client.verbosity = options[:verbose] ? 1 : 0
          puts "HTTP request/response details hidden (use -vv or -vvv for details)".cyan 
          
          # Silence Faraday logging for lower verbosity levels
          if defined?(Faraday.default_connection) && Faraday.default_connection
            begin
              Faraday.default_connection.builder.handlers.each do |handler|
                if defined?(Faraday::Response::Logger) && handler.klass == Faraday::Response::Logger && 
                   handler.instance_variable_defined?(:@logger) && handler.instance_variable_get(:@logger)
                  handler.instance_variable_get(:@logger).level = Logger::WARN
                end
              end
            rescue => e
              puts "Warning: Unable to configure logging: #{e.message}".yellow if options[:verbose]
            end
          end
          
          # Also try to silence the built-in logger in the client
          if client.respond_to?(:connection) && client.connection.respond_to?(:builder)
            begin
              client.connection.builder.handlers.each do |handler|
                if defined?(Faraday::Response::Logger) && handler.klass == Faraday::Response::Logger &&
                   handler.instance_variable_defined?(:@logger) && handler.instance_variable_get(:@logger)
                  handler.instance_variable_get(:@logger).level = Logger::WARN
                end
              end
            rescue => e
              puts "Warning: Unable to configure client logging: #{e.message}".yellow if options[:verbose]
            end
          end
        end
        
        # Set timeout for connection - modify the connection object if it's available
        begin
          if client.respond_to?(:connection) && client.connection.respond_to?(:options)
            client.connection.options.timeout = options[:timeout]
            client.connection.options.open_timeout = options[:timeout]
          end
        rescue => e
          puts "Warning: Unable to set timeout options: #{e.message}".yellow
        end
        
        begin
          # Establish a session that will be used for all tests
          # Force the creation of a new session and test it works
          if client.session.respond_to?(:delete) 
            client.session.delete rescue nil
          end
          
          session_created = client.session.create
          if !session_created && !client.direct_mode
            puts "Failed to establish a session, falling back to direct mode".yellow
            client.direct_mode = true
          end
          
          # Basic connection test
          puts "\n[TEST] Basic connection".cyan.bold
          begin
            version = client.redfish_version
            puts "✓ Connection successful, Redfish version: #{version}".green
            test_results["connection"] = { status: "PASS", message: "Connected to iDRAC successfully" }
          rescue Faraday::TimeoutError => e
            puts "✗ Connection timed out after #{options[:timeout]} seconds. Check host and network.".red
            test_results["connection"] = { status: "FAIL", message: "Connection timeout: #{e.message}" }
            puts "No further tests will be run until connection is established.".red
            break
          rescue => e
            puts "✗ Connection failed: #{e.message}".red
            test_results["connection"] = { status: "FAIL", message: e.message }
            puts "No further tests will be run until connection is established.".red
            break
          end
          
          # System info test
          puts "\n[TEST] System information".cyan.bold
          begin
            response = client.authenticated_request(:get, "/redfish/v1/Systems/System.Embedded.1")
            system_info = JSON.parse(response.body)
            puts "✓ System info: #{system_info['Model']} (#{system_info['SKU']})".green
            test_results["system_info"] = { status: "PASS", message: "Retrieved system information successfully" }
          rescue => e
            puts "✗ System info failed: #{e.message}".red
            test_results["system_info"] = { status: "FAIL", message: e.message }
            # If we can't get basic system info, stop testing
            break
          end
          
          # Power tests
          puts "\n[TEST] Power management".cyan.bold
          begin
            power_state = client.get_power_state
            puts "✓ Power state: #{power_state}".green
            
            watts = client.get_power_usage_watts
            puts "✓ Power usage: #{watts} watts".green
            test_results["power"] = { status: "PASS", message: "Retrieved power information successfully" }
          rescue => e
            puts "✗ Power tests failed: #{e.message}".red
            test_results["power"] = { status: "FAIL", message: e.message }
          end
          
          # Storage tests
          puts "\n[TEST] Storage management".cyan.bold
          begin
            controller = client.controller
            puts "✓ Storage controller: #{controller['Name']} (#{controller['Model']})".green
            
            drives = client.drives(controller)
            puts "✓ Found #{drives.size} physical drives".green
            
            volumes = client.volumes(controller)
            puts "✓ Found #{volumes.size} virtual disks".green
            test_results["storage"] = { status: "PASS", message: "Retrieved storage information successfully" }
          rescue => e
            puts "✗ Storage tests failed: #{e.message}".red
            test_results["storage"] = { status: "FAIL", message: e.message }
          end
          
          # System component tests
          puts "\n[TEST] System components".cyan.bold
          begin
            begin
              memory = client.memory
              puts "✓ Memory: #{client.total_memory_human(memory)}".green
              memory_test_status = "PASS"
              memory_test_message = "Retrieved memory information successfully"
            rescue => e
              puts "✗ Memory test failed: #{e.message}".red
              memory_test_status = "FAIL"
              memory_test_message = e.message
            end
            
            begin
              psus = client.psus
              puts "✓ Found #{psus.size} power supplies".green
              psu_test_status = "PASS"
              psu_test_message = "Retrieved PSU information successfully"
            rescue => e
              puts "✗ PSU test failed: #{e.message}".red
              psu_test_status = "FAIL"
              psu_test_message = e.message
            end
            
            begin
              fans = client.fans
              puts "✓ Found #{fans.size} fans".green
              fan_test_status = "PASS"
              fan_test_message = "Retrieved fan information successfully"
            rescue => e
              puts "✗ Fan test failed: #{e.message}".red
              fan_test_status = "FAIL" 
              fan_test_message = e.message
            end
            
            begin
              nics = client.nics
              puts "✓ Found #{nics.size} network interfaces".green
              nic_test_status = "PASS"
              nic_test_message = "Retrieved NIC information successfully"
            rescue => e
              puts "✗ NIC test failed: #{e.message}".red
              nic_test_status = "FAIL"
              nic_test_message = e.message
            end
            
            test_results["memory"] = { status: memory_test_status, message: memory_test_message }
            test_results["psus"] = { status: psu_test_status, message: psu_test_message }
            test_results["fans"] = { status: fan_test_status, message: fan_test_message }
            test_results["nics"] = { status: nic_test_status, message: nic_test_message }
          rescue => e
            puts "✗ System component tests failed: #{e.message}".red
            test_results["system_components"] = { status: "FAIL", message: e.message }
          end
          
          # Virtual media tests
          puts "\n[TEST] Virtual media".cyan.bold
          begin
            media = client.virtual_media
            puts "✓ Found #{media.size} virtual media devices".green
            test_results["virtual_media"] = { status: "PASS", message: "Retrieved virtual media information successfully" }
          rescue => e
            puts "✗ Virtual media test failed: #{e.message}".red
            test_results["virtual_media"] = { status: "FAIL", message: e.message }
          end
          
          # Boot management tests
          puts "\n[TEST] Boot management".cyan.bold
          begin
            boot_options = client.get_bios_boot_options
            puts "✓ Retrieved BIOS boot options".green
            
            boot_override = client.get_boot_source_override
            puts "✓ Boot source override: #{boot_override}".green
            test_results["boot"] = { status: "PASS", message: "Retrieved boot information successfully" }
          rescue => e
            puts "✗ Boot management test failed: #{e.message}".red
            test_results["boot"] = { status: "FAIL", message: e.message }
          end
          
          # Jobs and tasks
          puts "\n[TEST] Jobs and tasks".cyan.bold
          begin
            jobs = client.jobs
            puts "✓ Retrieved job queue information".green
            test_results["jobs"] = { status: "PASS", message: "Retrieved job information successfully" }
          rescue => e
            puts "✗ Jobs test failed: #{e.message}".red
            test_results["jobs"] = { status: "FAIL", message: e.message }
          end
          
        rescue => e
          puts "\n✗ Unexpected error during testing: #{e.message}".red.bold
          puts e.backtrace.join("\n").red if client.verbosity >= 2
        ensure
          # Clean up - make sure we delete the session to avoid leaving orphaned sessions
          begin
            if client.session.respond_to?(:delete) && client.session.x_auth_token
              client.session.delete 
            end
          rescue
            # Ignore errors during cleanup
          end
          
          # Restore original verbosity
          client.verbosity = original_verbosity
        end
        
        # Print summary
        puts "\n" + "=" * 80
        puts "TEST SUMMARY:".green.bold
        puts "=" * 80
        
        pass_count = test_results.count { |_, v| v[:status] == "PASS" }
        fail_count = test_results.count { |_, v| v[:status] == "FAIL" }
        
        test_results.each do |test_name, result|
          status_color = result[:status] == "PASS" ? :green : :red
          puts "#{test_name.ljust(20)}: #{result[:status].send(status_color)} - #{result[:message]}"
        end
        
        puts "=" * 80
        puts "OVERALL: #{pass_count} passed, #{fail_count} failed".send(fail_count == 0 ? :green : :yellow).bold
        puts "=" * 80
      end
    end
    
    private

    def with_idrac_client
      ensure_host_provided
      check_ssl_verification
      client = create_client
      
      # Set verbosity level for the client
      if client.respond_to?(:verbosity=)
        if options[:debug]
          client.verbosity = 3
        elsif options[:very_verbose]
          client.verbosity = 2
        elsif options[:verbose]
          client.verbosity = 1
        else
          client.verbosity = 0
        end
      end
      
      # Execute command with proper error handling
      begin
        yield client
      rescue IDRAC::Error => e
        puts "Error: #{e.message}".red.bold
        exit 1
      ensure
        client.logout
      end
    end

    def ensure_host_provided
      if !options[:host]
        puts "Error: No value provided for required option '--host'".red.bold
        exit 1
      end
    end

    def check_ssl_verification
      # If verify_ssl is not explicitly set in the command line, show a warning
      unless ARGV.include?('--verify-ssl') || ARGV.include?('--no-verify-ssl')
        puts "WARNING: SSL verification is disabled by default. iDRAC typically uses self-signed certificates.".yellow
        puts "         Use --verify-ssl if you want to enable SSL verification.".yellow
        puts ""
      end
    end

    def create_client
      IDRAC::Client.new(
        host: options[:host],
        username: options[:username],
        password: options[:password],
        port: options[:port],
        use_ssl: !options[:no_ssl],
        verify_ssl: options[:verify_ssl],
        auto_delete_sessions: options[:auto_delete_sessions],
        retry_count: options[:retries],
        retry_delay: options[:retry_delay]
      )
    end
  end
end

# Start the CLI
IDRAC::CLI.start(ARGV) 